# 任意方程求根

## 1.简介

方程和函数是代数数学中最为重要的内容之一，从初中直到大学，我们都在研究着方程与函数，甚至我们将图形代数化，从而发展出了代数几何、解析几何的内容。而在方程与函数中，我们研究其性质最多的，往往就是方程的根（零点），即使是研究方程的极值点、鞍点等，我们无非也只是研究其微商的零点。
我们在初等数学中已经学过许多简单初等函数、线性方程的求解方法，在本文中，我们重点讨论任意方程，尤其是计算困难的非线性方程的求根方法。

## 2.方程

### 2.1分类和介绍

方程就是指含有未知数的等式。是表示两个数学式（如两个数、函数、量、运算）之间相等关系的一种等式，使等式成立的未知数的值称为“解”或“根”。在这里，根据一些性质的不同，我们将方程分成以下几类：

- 单个方程
  - 线性方程：本质是等式两边乘以任何相同的非零数，方程的本质都不受影响。通常认为只含有一次项的方程。
  - 非线性方程：是因变量与自变量之间的关系不是线性的关系的方程。
    - 多项式方程
    - 超越方程：指含有未知量的超越式（指数、对数、三角函数、反三角函数等）的方程。换言之，超越方程中都有无法用含有未知数的多项式、分式或开方表示的式子。
- 多个方程
  - 线性方程组
  - 非线性方程组

### 2.2方程的零点（根、解）

若有一个值或一些值能够使得方程 $f(x)=0$ 成立，那么这个值就被成为方程的解，也常常被叫做零点和根。

若方程有且只有一个解$x^*$，那么我们称方程有单根$x^*$。

若对于方程$f(x)=0$，有$f(x^*) = 0,f^{'}(x^*)=f^{''}(x^*)=\cdots=f^{(k)}(x^*)=0,f^{(k+1)}(x^*)\neq0$,那么称$x^*$为方程的k+1重根

PS：若方程是简单幂函数多项式组成，那么方程的解的数量应和最高此项的数值一致，因为存在虚根。

## 3.求根方法

求根的方法基本上大同小异，都是通过区间去逼近方程的根的点。

首先我们说一个定理1：对于实函数方程$f(x)=0$，当$x\in(a,b)$，且$f(x)$在$x\in(a,b)$时单调且连续，若$f(a)\cdot f(b)<0$，则方程在$x\in(a,b)$有且只有一个根。

### 3.1二分法

#### 3.1.1普通二分法的原理及操作

二分法和算法中的二分搜索法非常的类似，取定有根区间$[a,b]$进行对分，求得$mid = \frac{a+b}{2}$进行判断含根区间，如果$f(a)\cdot f(mid)<0$,则令$b=mid$；反之若$f(b)\cdot f(mid)<0$,则令$a=mid$。当$|b_n-a_n|<\epsilon$停止计算返回结果。

产生的截断误差为$|e_{n-1}| = x_{n+1} - x^*\leq[b_n - a_n] = \frac{b_0 - a_0}{2^n}$。

可以计算出最小迭代次数为$n = \frac{lg(c_0-a_0)-lg\epsilon}{lg2}$

代码实现（更多语言的代码见仓库中Code文件夹）：

``` C#
private static double epsilon = 0.001;
// func为函数，写法如x=>x*x+2*x-1，a，b必须为有效的含根开区间
public static double Binary(Func<double, double> func, double a, double b)
{
    var f1 = func.Invoke(a);
    var f2 = func.Invoke(b);
    if (f1 * f2 > 0)
        throw new ArgumentException("此区间无根或根不唯一");
    double mid = (a + b) / (double)2;
    var fm = func.Invoke(mid);
    if (fm == 0)
        return fm;
    if (f1 * fm < 0)
        b = mid;
    else if (f2 * fm < 0)
        a = mid;
    if (Math.Abs(b - a) <= epsilon)
        return (a + b) / (double)2;
    return Binary(func, a, b);
}
```

#### 3.1.2普通二分法准确度及速度分析

假设$\left[a,b\right]$是二分法的初始区间，在进行n此二分之后，得到的最终根的分布区间$[a_n,b_n]$的长度为$(b-a)/2^n$，我们将其中点作为根的最优估计值，与真实值之间的误差不超过区间长度的一半。

$$
e = \left|x_c-r\right|<\frac{b-a}{2^{n+1}}
$$
若$e<\frac{1}{2}\times10^{-p}$,则精确到小数点后p位，

事实上我们也可以简单的计算出函数执行的次数为n+2次。

### 3.2浅谈迭代

#### 3.2.1 迭代是什么

#### 3.2.2 不动点的定义

各位可以尝试以下操作，

1. 随意输入一个数字$\lambda$
2. 然后对其进行$cos\lambda$运算，
3. 将运算结果作为新的值传回$cosx$函数之中

当你一直重复以上三个操作，你会发现数字最后会定格在0.73908513左右不动了。这是一个非常有趣的现象，事实上我们的这个操作就是$x_n = cosx_{n-1}$，而最后不变化的数值实际上就是$x = cosx$这个方程的解。

这就是我们不动点的一种实际情况，不动点原理是数学上一个重要的原理，也叫压缩映像原理或巴拿赫（Banach）不动点定理，完整的表达：完备的度量空间上，到自身的一个压缩映射存在唯一的不动点。用初等数学可以这么理解：连续映射$f$的定义域包含值域，则存在一个$x$使得$f(x)=x$。

若某函数满足$f(\lambda)=\lambda,\lambda \in R$，我们就称$\lambda$为函数的一阶不动点。同样的，我们推广一下，若$f(f(\lambda))=\lambda,\lambda \in R$，则称为二阶不动点，一阶不动点必定是二阶不动点。

**不动点的存在定理**：若某函数$y=f(x)$与$y=x$存在至少一个交点，那么函数必然存在不动点。

#### 3.2.3 函数的相似性

我们常常说图形之间的相似，事实上函数也有其相似的定义。若函数$f(x)$对其换元，令$t = \varphi(x),x=\varphi^{-1}(t),f(x)=>f(\varphi^{-1}(t))$。我们的不动点是一个基于迭代的过程，迭代就是让$f(x_0) = x_1 = t,f(x_1)=f(f(x_0))=f(t)=x_2...$的过程，如果我们换个角度去思考，迭代不就是和我们刚刚提到的换元是一个道理吗？那么我们思考一下，如果对于二次迭代$f(f(x))$，如果说我们把函数完全看成是一个复合函数，那么我们现在需要做的就是试图将函数写成$f(\varphi^{-1}(t))$的形式。

现在做出如下变换，将外层的$f(x)$换元为$f(\varphi^{-1}(t))$，那么二次迭代式就变成了$g(t) = \varphi(f(\varphi^{-1}(t)))$。随后对我们的$g(x)$再进行迭代就会得到$g(g(t)) = \varphi(f(f(\varphi^{-1}(t)))$，利用数学归纳法计算n次迭代式，那么就会得到$g_n(t) = \varphi(f_n(\varphi^{-1}(t)))$。

我们在这给出总结和定义：若函数$g(x),f(x),\varphi(x)$，若有$g(x)=\varphi(f(\varphi^{-1}(x)))$，那么称函数$g(x)$和$f(x)$通过$\varphi(x)$相似，记作$f\sim g$，$\varphi(x)$称为相似的桥函数，且之前我们的过程得出了一个重要的结论就是$g\sim f=>g^n\sim f^n$，同时，相似函数的不动点是完全一致的，证明如下：

$$
若函数g(x)的不动点为x_0，则有
$$
$$
g(x_0)=x_0=\varphi(f(\varphi^{-1}(x_0)))
$$

$$
根据反函数性质有\varphi(\varphi^{-1}(x))=x
$$

$$
故f(\varphi^{-1}(x_0)) = \varphi^{-1}(x_0)=x_0,\varphi^{-1}(x_0)是f(x)的一个不动点
$$

通过上述得出的不动点，很容易通过刚才讲的内容得出$\varphi^{-1}(x_0)$实际上也是$g(x)$换元后得到的不动点的位置，因此相似函数的不动点是一一对应的。

#### 3.2.4 迭代收敛速度

迭代是一种逼近、利用数列、函数收敛的性质进行求解的方法，那么对于收敛的速度，我们很难直接从数值看出速度，因为收敛过程中，误差的变化是越来越小的，因此我们再次进行一个比阶。

$$\exists p\in N \And C>0,\displaystyle \lim_{k \to \infty}\frac{e_{k+1}}{e_k^p} = C$$

其中：

$$e_k = |x_k-x^*|$$

$$
p=
\begin{cases}
p=1,线性收敛\\
p=2,平方收敛\\
p>2,高阶收敛
\end{cases}
$$

并且有一个定理：若$\varphi(x)$在所求的根$x^*$邻域有连续的二阶导数，并且有$|\varphi^{'}(x)|<1$，有以下特点：

1. 当$\varphi^{'}(x)\neq0$，那么迭代过程线性收敛

2. 当$\varphi^{'}(x)=0,\varphi^{''}(x)\neq0$，那么迭代是平方收敛的。

证明过程留给读者，只需要利用泰勒展开是便可以证明该定理。


### 3.3不动点迭代法

#### 3.3.1不动点迭代法的原理及操作

迭代法是将方程求根问题转换成了函数求交点问题再转换成数列求极限的问题，这个过程中，对方程进行一个巧妙的变换之后，方程就可以在若干次迭代之后解出一个近似解。

操作方法如下：首先将方程$f(x)=0$改写成$x = g(x)$的形式，这样就可以将方程的解看成是函数$y=x$和$y=g(x)$的交点。给定初始值$x_0$后，则$x_1 = g(x_0)$，不断重复这个过程，若$\displaystyle \lim_{k \to \infty}x_k$存在，则迭代便可以达到使得$x_k$趋于交点，而这个交点就是我们刚才讲了那么久的不动点。

我们即使构造出了$x=g(x)$的迭代式，往往由于我们的变换只是一些简单的移项、通分等四则运算获得，使得迭代式也并不是一个很容易被计算的函数，这个时候，我们之前讲到的那么多函数相似就派上了用场，我们可以利用函数相似性去寻找一个更为简单的函数$\varphi(x)\sim g(x)$，由于相似的性质，不动点并不会发生变化。不过，我们需要保证最终的迭代函数在指定的含根区间内的导数值$|\varphi^{'}(x)|<1$，否则迭代函数将会不收敛。

迭代过程如下图所示：
![avatar](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_2007130920532020052000073049.png)

#### 3.3.2迭代法的收敛性证明

在这里，我们将证明迭代法求根的合理性和可行性。

前提条件：设函数$\varphi(x), x\in[a,b]$有连续的一阶导数，并且满足以下条件：

- $\forall x\in [a,b],\varphi(x)\in[a,b]$

- $\exists L \in (0,1),\forall x\in[a,b],|\varphi^{'}(x)|\leq L$

要证明和解决以下命题和问题：

- 在$x\in[a,b],\exists x^*,\varphi(x^*) = 0$
  
- $\forall x_0\in[a,b]$，迭代过程$x_{k+1} = \varphi(x_k)$均收敛与$x^*$

- 求解误差分析式

现在开始证明

1：证明在区间内有且只有一个根存在：

证：在$x \in [a,b]$时，$\varphi^{'}(x)$存在，所以有$\varphi(x)$连续，于是可以作$g(x) = x - \varphi(x)$，易知$g(x)$连续。

又因为$\varphi(x) \in [a,b]$，且$g(a)*g(b)<0$,故存在实根，使得$x=\varphi(x)$。

利用反证法：若在[a,b]上还有一实根$\bar{x}$，那么通过拉格朗日中值定理必定有：

$$x^*-\bar{x} = \varphi(x^*)-\varphi(\bar{x}) = \varphi^{'}(\xi)(x^*-\bar{x})\Longrightarrow \varphi^{'}(\xi) = 1$$

显然与假设不符合。

2：证明这个根收敛于$x^*$

根据拉格朗日中值定理，容易知道

$$x^*-x_{k+1} = \varphi(x^*)-\varphi(x_k) = \varphi^{'}(\xi)(x^*-x_k)$$

又因$|\varphi^{'}(x)|\leq L$，故易得：

$$|x^*-x_{k+1}|\leq|L(x^*-x_k)|=|L^2(x^*-x_{k-1})=\cdots=|L^k(x^*-x_0)|$$

因为$\displaystyle \lim_{k \to \infty}L^k=0$，故$\displaystyle \lim_{k \to \infty}|x^*-x_{k+1}|=0$(绝对值必定非负)，得$x^*=x_{k+1}(k\to\infty)$

3:迭代法的误差式：

设某一次迭代后误差为$\epsilon$，则可以推出：

$$|x_{k+1}-x_{k}| = |(x^*-x_k)-(x^*-x_{k+1})\geq|x^*-x_k|-|x^*-x_{k+1}|\geq|x^*-x_k|-L|x^*-x_k|$$

其中从$|x^*-x_{k+1}| \leq L|x^*-x_k|$则是因为每一次迭代后，误差总是减少的。

故可以轻松的计算出误差估计式为：

$$|x^*-x_k|\leq\frac{1}{1-L}|x_{k+1}-x_k|$$

通过中值定理，又可以推出：

$$|x_{k+1}-x_k| = |\varphi^{'}(\xi)(x_k-x_{k-1})|$$

因为$|\varphi^{'}(\xi)|\leq L$，将上式递推后放缩成第二种误差估计式：

$$|x^*-x_k|\leq\frac{L^k}{1-L}|x_1-x_0|$$

#### 3.3.3不动点迭代法的收敛速度

首先我们先直接给出一个结论：**在不动点迭代过程中，第i步迭代和第i+1步迭代的表达式分别为**$e_i,e_{i+1}$，且有$\displaystyle \lim_{ i \to \infty}\frac{e_{i+1}}{e_i}=S<1\neq0$，因此不动点迭代法是一个线性收敛的算法。

如何能证明我们的算法是一个线性收敛的函数呢？实际上非常简单。


``` C#
// func是迭代函数而不是实际函数
public static double Iterative(Func<double, double> func, double x)
{
    double temp = func.Invoke(x);
    if (Math.Abs(temp - x) <= epsilon)
    {
        return temp;
    }
    x = temp;
    return Iterative(func, x);
}
```

### 3.4牛顿法

牛爵爷在整个微积分、数值分析中都有着举足轻重的地位，这里阐述的牛顿法，就是Taylor展开式的一部分。牛顿迭代法的核心思想就是：设法将一个非线性方程$f(x)=0$转化为某种线性方程去求解。在数学意义上，我们知道泰勒公式可以将任意函数以简单幂函数的形式表示出来，而在几何意义上，我们是利用切线与X轴的交点去进行迭代，在根处，切线必过零点。若设$f(x)=0$的近似解为$x_k$，则方程可以用一阶Taylor展开进行近似表示，牛顿迭代法的核心公式如下：

$$p_1(x) = f(x_k)+f^{'}(x_k)(x-x_k)$$

#### 3.4.1普通牛顿法

从上述公式中我们知道，其中$p_1(x)$就是泰勒多项式的表达，将其看成是方程$f(x)=0$，通过迭代的思想，从而得到了一个线性方程：

$$x_{k+1} = x_k - \frac{f(x_k)}{f^{'}(x_k)}$$

这就是普通牛顿法的迭代公式。在几何意义上，他就是一个切线与x轴的交点去逼近零点，如图：

![newtown](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200715013518v2-ea00a4c57c49e64123c56ebb06340f0c_r.png)

#### 3.4.2牛顿下山法

所有的迭代法都有一个无法逃过的缺点，如果选取的初始值离根太远，则会导致迭代过程次数过多，并且有可能导致迭代发散，因为迭代法只具有局部收敛性。

为了避免迭代失败或时间过长，我们加上这样一个条件用于保证数值稳定下降

$$|f(x_{k+1})|<|f(x_k)|$$

将这个条件和牛顿法结合再一起，即再保证数值稳定下降的过程中，利用牛顿法加快迭代，这就是牛顿下山法。具体的操作如下：

将牛顿法的结果$\bar{x}_{k+1}$与前一步的迭代值$x_k$进行加权平均作为新的迭代值$x_{k+1}$，

则有：

$$x_{k+1} = \lambda\bar{x}_{k+1} + (1-\lambda)x_k$$
或
$$x_{k+1} = x_k - \lambda\frac{f(x_k)}{f^{'}(x_k)}$$

其中$\lambda(0\leq\lambda<1)$称为下山因子，它的值是一个逐步试探的过程，可以从1开始取值，一旦满足$|f(x_{k+1})|<|f(x_k)|$则称为下山成功，否则需要另选初始值$x_0$进行试算。

#### 3.4.3简单牛顿法

牛顿法可以说是一个非常有效的计算方法，准确度和迭代次数上都要比普通的迭代法要好得多，但是牛顿法最大的问题是我们需要求方程的导数，对于某些极其复杂的函数而言，导数是无法通过人工的方式计算，假如我们使用微积分的方式去求解导数，这对整个程序的性能会有比较大的影响，因此我们可以利用一个常数值$\lambda$来代替方程中的导数项。此时迭代公式为：

$$x_{k+1} =x_k - \frac{f(x_k)}{\lambda}$$

不过对于常数$\lambda$的取值是有限制的，因为我们需要保证迭代函数的收敛性，如果函数不收敛于$x^*$，那么一切都没有意义。于是有：

$$\varphi(x) = x - \frac{f(x)}{\lambda}\Longrightarrow\varphi^{'}(x) = 1-\frac{f^{'}(x)}{\lambda}$$

牛顿迭代法的收敛性遵循前文中普通迭代法的收敛性，于是可以得到：

$$|\varphi^{'}(x)| = |1-\frac{f^{'}(x)}{\lambda}|\Longrightarrow0<\frac{f^{'}(x)}{c}<2$$

这样我们就可以很轻松的确定下c的值了。

简单牛顿法的几何意义就简单许多了，和我们之前讨论的普通迭代法一致，只不过普通迭代法是将函数值和$y=x$进行处理变换，而简单牛顿法则是和$y= \lambda(x-x_k)+f(x_k)$进行变换，本质是一致的。

``` C#
///这里只写普通牛顿法，另外的函数由读者自己思考
// 其中f1x为导数
public static double Newtown(Func<double, double> fx, Func<double, double> f1x, double x)
{
    var temp = f1x.Invoke(x);
    if (temp == 0)
    {
        throw new ArgumentException();
    }
    x = x - fx.Invoke(x) / temp;
    if (Math.Abs(fx.Invoke(x)) <= epsilon)
    {
        return x;
    }
    return Newtown(fx, f1x, x);
}
```

#### 3.4.4改进牛顿法——弦截法

弦截法是牛顿法的一种改进，保留了牛顿法中收敛速度快的优点，还克服了再牛顿法中需要计算函数导数值$f^{'}$的缺点。

弦截法中，我们用差商

$$\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$$

去代替牛顿法中的导数值，于是可以得到以下离散化的迭代

$$x_{k+1} = x_k - \frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1})$$

这种方法叫做双点弦截法，如图所示：

![弦截法](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200715030753QQ%E6%88%AA%E5%9B%BE20200715110721.png)

从图中可以知道，弦截法一直利用两点之间的连线作为迭代的内容，那么，他的合理性在哪里呢？

整个迭代法都离不开中值定理，这里也是这样，事实上，这个差商之所以可以对导数值进行替代，是因为中值定理中说过，连续函数中两函数上的点的连线的斜率必为两点之间某一点的导数值，并且迭代过程中，这两点的中值会越来越逼近函数零点，事实上这已经说明了弦截法是牛顿法的改进方法了。

不过，如果将函数中$x_{k-1}$用一个定点$x_0$代替，这种方法叫做单点弦截法，几何意义如图所示：

![单点弦截法](https://images.cnblogs.com/cnblogs_com/WarrenRyan/1643641/o_200715031635QQ%E6%88%AA%E5%9B%BE20200715111615.png)

``` C#
//这里就对双点弦截法进行编程
public static double StringCut(Func<double, double> func, double x1, double x2)
{
    var temp = x1 - (func.Invoke(x1) / (func.Invoke(x1) - func.Invoke(x2))) * (x1 - x2);
    x2 = x1;
    x1 = temp;
    if (Math.Abs(func.Invoke(x1)) <= epsilon)
    {
        return x1;
    }
    return StringCut(func, x1, x2);
}
```

### 3.5拟牛顿法*（拓展）

#### 3.5.1 DFP

#### 3.5.2 BFGS

#### 3.5.3 Broyden

## 收敛迭代的加速

### 普通迭代加速

对于迭代过程，利用中值定理有

$$x^*-x_{k+1} = \varphi(x^*)-\varphi(x_k) = \varphi^{'}(\xi)(x^*-x_k)$$

当$\Delta x \rightarrow0$，我们将$\varphi^{'}(\xi)$看成定值$\lambda(\lambda<1)$

于是有

$$\lambda(x^*-x_k) = x^*-x_{k+1}\longrightarrow x^* = \frac{1}{1-\lambda}\bar{x}_{k+1}-\frac{\lambda}{1-\lambda}x_k$$

故可以推出最终的迭代公式为

$$
\begin{cases}
\bar{x}_{k+1} = \varphi(x_k)\\
x_{k+1} = \bar{x}_{k+1} + \frac{\lambda}{1-\lambda}(\bar{x}_{k+1}-x_k)
\end{cases}
$$

利用这种方式的好处就是再求得$x_k$时，利用加权的方式，使得迭代法变得有点类似像牛顿迭代法一样变成切线性质的线而不是x=c或y=c的线，你经过画图和简单的代数运算后，你会发现$\bar{x}_{k+1}<x_{k+1}$，也就是说达到了我们的加速目的。

### Atiken加速法

Atiken加速法其实就是再普通加速迭代公式上在进行一次迭代，这里直接写出公式：

$$
\begin{cases}
\bar{x}_{k+1} = \varphi(x_k)\\
\bar{\bar{x}}_{k+1} = \varphi(\bar{x}_{k+1})\\
x_{k+1} = \bar{\bar{x}}_{k+1} - \frac{(\bar{\bar{x}}_{k+1}-\bar{x}_{k+1})}{\bar{\bar{x}}_{k+1} - 2\bar{x}_{k+1}+x_k}
\end{cases}
$$

## Reference

> 《数值分析》（原书第二版） —— Timothy Sauer
>
> 《数值计算方法》（清华大学出版社） —— 吕同富等

## About Me

<p id="PSignature" style="padding-top: 10px; padding-right: 10px; padding-bottom: 10px; padding-left: 60px; background: url(&quot;https://www.cnblogs.com/images/cnblogs_com/ECJTUACM-873284962/1318325/o_o_122329534672560.png&quot;) #e5f1f4 no-repeat 1% 50%; font-family: 微软雅黑; font-size: 12px; border: #e0e0e0 1px dashed"> <br>
        作　　者：<strong><span style="font-size: 12px; color: red"><a href="https://www.cnblogs.com/WarrenRyan/" target="_blank">WarrenRyan</a></span></strong>
        <br>
        出　　处：<a href="https://www.cnblogs.com/WarrenRyan/" target="_blank">https://www.cnblogs.com/WarrenRyan/</a>
        <br>
        本文对应视频：<a href="" target="_blank">BiliBili(待重录)</a>
        <br>
        关于作者：热爱数学、热爱机器学习，喜欢弹钢琴的不知名小菜鸡。
        <br>
        版权声明：本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。若需商用，则必须联系作者获得授权。
        <br>
        特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者<a href="http://msg.cnblogs.com/msg/send/WarrenRyan">直接私信</a>我
        <br>
        声援博主：如果您觉得文章对您有帮助，可以点击文章右下角<strong><span style="color: #ff0000; font-size: 18pt">【<a id="post-up">推荐</a>】</span></strong>一下。您的鼓励是作者坚持原创和持续写作的最大动力！
        <br>
        <br>
        <br>
        博主一些其他平台：
        <br>
        <strong><a>微信公众号：寤言不寐</a></strong>
        <br>
        <strong><a href="https://space.bilibili.com/33311288" target="_blank">BiBili——小陈的学习记录</a></strong>
        <br>
        <strong><a href="https://github.com/StevenEco" target="_blank">Github——StevenEco</a></strong>
        <br>
        <strong><a href="https://space.bilibili.com/667199655" target="_blank">BiBili——记录学习的小陈（计算机考研纪实）</a></strong>
        <br>
        <strong><a href="https://juejin.cn/user/3756401007016173" target="_blank">掘金——小陈的学习记录</a></strong>
        <br>
        <strong><a href="https://space.bilibili.com/33311288" target="_blank">知乎——小陈的学习记录</a></strong>
        <br>
    </p>
<br/>
<div>
<div class="github-card" data-github="StevenEco" data-width="350" data-height="150" data-theme="default"></div>
<div class="github-card" data-github="StevenEco/.NetCoreGuide" data-width="350" data-height="150" data-theme="default"></div>
</div>

## 联系方式

<a style="font-family: 微软雅黑; font-size: 18px;" href="mailto:cxtionch@gmail.com">电子邮件：cxtionch@live.com</a>
<br/>
<br/>
<p style="font-family: 微软雅黑; font-size: 18px;">社交媒体联系二维码：</p>
<img style=" width: 100%" src="https://images.cnblogs.com/cnblogs_com/WarrenRyan/2090249/o_220106070541_%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E6%A0%8F.jpg"/>
